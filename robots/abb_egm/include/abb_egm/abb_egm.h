/*
	ABBEGM: wrapper for direct interface with ABB External-Guided-Motion (EGM).
	Create a thread to maintain 250Hz communication with EGM, manage set/get poses in Monitor().

	The 250Hz communication runs in separate thread and is independent of user usage. User can call
	set and get at any rate.

	When calling init(), the program receive the pose of the robot, use it to initialize _set_pose
	before sending the first command.

	Currently, only Cartesian mode is implemented.

	Author:
		Yifan Hou <yifanh@cmu.edu>
*/

#ifndef _EGM_CLASS_HEADER_
#define _EGM_CLASS_HEADER_

#include <thread>
#include <fstream>
#include <string>
#include <cstdlib>
#include <chrono>

#include <ros/ros.h>

// For UDPSocket and SocketException
#include <practical_socket/PracticalSocket.h>
// generated by Google Protobuf-compiler
#include "egm.pb.h"

#include "hardware_interfaces/robot_interfaces.h"

using namespace abb::egm;

#define EGM_PERIOD 4.0 // 4ms

typedef std::chrono::high_resolution_clock Clock;


class ABBEGM : public RobotInterfaces {
public:
	/// for singleton implementation
	static ABBEGM* Instance();

	/**
	 * Initialize egm communication. Create a thread to run the  250Hz
	 * communication with egm. The function will read parameters from ROS
	 * parameter server.
	 *
	 * @param      root_nh  ROS node handle. Used to access parameters.
	 * @param[in]  time0    Start time. Time will count from this number.
	 *
	 * @return     True if success.
	 */
	int init(ros::NodeHandle& root_nh, Clock::time_point time0);

	bool getCartesian(double *pose) override;
	bool setCartesian(const double *pose) override;

	/**
	 * Not implemented yet
	 */
	bool getJoints(double *joints) override;
	bool setJoints(const double *joints) override;



private:
	/**
	 * For singleton implementation
	 */
	static ABBEGM* pinstance;
	ABBEGM();
	ABBEGM(const ABBEGM&){}
	ABBEGM& operator= (const ABBEGM&){}
	~ABBEGM();

	// callbacks
	void EGM_JOINT_MODE_MONITOR();
	void EGM_CARTESIAN_MODE_MONITOR();

	// socket utilities
	int listen();
	void send(double* set_cmd);
	int CreateCartesianTargetSensorMessage(const float* pose,
		EgmSensor* pSensorMessage);
	int CreateJointTargetSensorMessage(const float* joints,
		EgmSensor* pSensorMessage);
	void CreateSensorMessageEmpty(EgmSensor* pSensorMessage);
	void ReadRobotMessage(EgmRobot *pRobotMessage);
	void DisplayRobotMessage(EgmRobot *pRobotMessage);

	// robot state
	double *_pose;
	double *_joints;
	double *_set_pose;
	double *_set_joints;

	// thread
	std::thread _thread;

	// socket connection
	UDPSocket _EGMsock;
	string _sendBuffer;
	string _RobotAddress;
	unsigned short _RobotPort;

	// Egm message
	EgmSensor *_pSendingMessage;
	EgmRobot *_pRecvMessage;

	// MISC
	Clock::time_point _time0;
	ofstream _file;
	bool _print_flag;
};

#endif
