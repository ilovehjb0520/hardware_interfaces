/*
	EGMClass: wrapper for direct interface with ABB External-Guided-Motion (EGM).
	Create a thread to maintain 250Hz communication with EGM, manage set/get poses in Monitor().

	The 250Hz communication runs in separate thread and is independent of user usage. User can call 
	set and get at any rate.

	When calling init(), the program receive the pose of the robot, use it to initialize _set_pose 
	before sending the first command.

	User can read pose by calling GetCartesian().
	There are three mode for using this class.
	1. Position mode. SetCartesian() and SetCartesianVel() are available.   
	2. Velocity mode. SetVelocity() is available. (Cartesian velocity)
	3. Transparent mode. listen() and send() can be used directly.
	
	In all modes, the final pose command will be checked against  speed_limit_tran and speed_limit_rot.

	This particular class has no dependency on ROS, ros_control, etc.


	Yifan Hou <yifanh@cmu.edu>
*/

#ifndef _EGM_CLASS_HEADER_
#define _EGM_CLASS_HEADER_

#include <pthread.h>
#include <mutex>
#include <thread>
#include <fstream>
#include <string>
#include <cstdlib>
#include <chrono>

#include <egm/practical_socket/PracticalSocket.h> // For UDPSocket and SocketException
#include <egm.pb.h> // generated by Google Protobuf-compiler

using namespace abb::egm;

/// Safety Mode. Determines the behavior when commanded pose is too far away.
/// SAFETY_MODE_NONE: Do not perform safety checking.
/// SAFETY_MODE_TRUNCATE: Truncate the commanded pose based on _max_dist_tran and _max_dist_rot
/// SAFETY_MODE_STOP: Throw an error and stop EGM.
typedef enum
{
	SAFETY_MODE_NONE,
	SAFETY_MODE_TRUNCATE,
	SAFETY_MODE_STOP
} EGMSafetyMode;

typedef enum
{
	OPERATION_MODE_CARTESIAN,
	OPERATION_MODE_JOINT
} EGMOperationMode;

// #define CARTESIAN_MOVE 0
// #define JOINT_MOVE 1

#define EGM_PERIOD 4.0 // 4ms

class EGMClass
{
public:
	/// for singleton implementation 
	static EGMClass* Instance();

	// ----------------------------------------
	// 	user interfaces
	// ----------------------------------------

	/// Establish communication with abb egm, create thread to run communication with EGM
	/// \param time0: a time object. The time computed in this program will count from time0.
	/// \param portnum the port number 
	/// \param speed_limit_tran speed limit for translation, mm/s 
	/// \param speed_limit_rot speed limit for rotation, degree/s
	/// \param safezone. EGM will stop if pose feedback violated this range at any time. [xmin xmax ymin ymax zmin zmax]
	/// \param mode a EGMSafetyMode variable specifying safety behavior.
	/// \param _print_flag optional. If true, the pose data and time stamp will get logged. If specified, you must also specify fillfullpath.
	/// \param filefullpath optional.
	int  init(std::chrono::high_resolution_clock::time_point time0, unsigned short portnum, float max_dist_tran, float max_dist_rot, float *safe_zone, EGMSafetyMode sf_mode, EGMOperationMode op_mode, bool _print_flag = false, string filefullpath = "");
	///  Interface for reading robot pose. The pose is updated every 4ms. 
	/// Must be called after initialization.
	/// \param pose a pointer to a dim=7 array. 
	bool GetCartesian(float *pose);
	/// Set the desired robot cartesian pose. The first 3 corresponds to 
	/// translation in mm while the last 4 is quaternion qw, qx, qy, qz.
	/// \param pose dim = 7.
	bool SetCartesian(const float *pose);

	bool GetJoints(float *joints);
	bool SetJoints(const float *joints);


	/// Wait until obtaining a message from egm. Then read it using ReadRobotMessage().
	/// \sa ReadRobotMessage()
	int listen();
	/// Send a message to egm. The command will be checked by _max_dist_tran 
	/// and _vel_limit_rot
	void send(float* set_cmd);

	// ----------------------------------------
	// 	state and parameters
	// ----------------------------------------
	float *_set_pose; ///< goal robot pose. dim = 7
	float *_set_joints; // target robot joint. dim = 6.
	bool _isInitialized; ///< indicates whether the initialization() function is called.
	EGMSafetyMode _safetyMode; ///< controller mode
	EGMOperationMode _operationMode; ///< controller mode
	float _max_dist_tran; ///< mm
					      ///< \sa initialization()
	float _max_dist_rot; ///<  rad
							 ///< \sa initialization()
	float *_safe_zone; ///< xmin,xmax,ymin,ymax,zmin,zmax

	// MISC
	std::chrono::high_resolution_clock::time_point _time0; ///< high resolution timer.
	ofstream _file;
	bool _print_flag;


private: 
	/// for singleton implementation 
	static EGMClass* pinstance; 
	/// for singleton implementation 
	EGMClass(); 
	/// for singleton implementation 
	EGMClass(const EGMClass&); 
	/// for singleton implementation 
	EGMClass& operator= (const EGMClass&); 
	~EGMClass(); 


	/// Create a protocol buffer message based on commanded cartesian pose.
	int CreateCartesianTargetSensorMessage(const float* pose, 
		EgmSensor* pSensorMessage);
	/// Create a protocol buffer message based on commanded joint.
	int CreateJointTargetSensorMessage(const float* joints, 
		EgmSensor* pSensorMessage);

	/// Create an empty message based
	void CreateSensorMessageEmpty(EgmSensor* pSensorMessage);
	/// Read the current pose from a robot message.
	void ReadRobotMessage(EgmRobot *pRobotMessage);
	/// Display the info contained in a robot message.
	void DisplayRobotMessage(EgmRobot *pRobotMessage);

	// robot state
	float *_pose; ///< robot pose. dim = 7
	float *_joints; ///< robot joint. dim = 6
	// thread
	pthread_t _thread;


	// socket connection
	UDPSocket _EGMsock;
    string _sendBuffer;
    string _RobotAddress;  
    unsigned short _RobotPort;

	// Egm message
    EgmSensor *_pSendingMessage;
    EgmRobot *_pRecvMessage;
};

#endif
